ÙÙ„Ø¯Ø± Ø¨Ù†Ø¯ÛŒ Ù‡Ø§ uploads
Ø±Ø§Ù‡â€ŒØ­Ù„: ØªØºÛŒÛŒØ± Ù†Ø§Ù… ÙØ§ÛŒÙ„ Ø±ÙˆÛŒ Ø¯ÛŒØ³Ú©

Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø§Ø³Ù… ÙØ§ÛŒÙ„ Ø±ÙˆÛŒ Ø¯ÛŒØ³Ú© Ù‡Ù… ØªØºÛŒÛŒØ± Ú©Ù†Ù‡ØŒ Ø¨Ø§ÛŒØ¯ Ø§Ø² fs/promises.rename() Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒ ØªØ§ ÙØ§ÛŒÙ„ Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ø¨Ø´Ù‡.
ØªØºÛŒÛŒØ± Ø¯Ø± PUT Ù…ØªØ¯:

Ø§ÛŒÙ† Ù‚Ø³Ù…Øª Ø±Ùˆ Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ PUT Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒ:

import { rename } from 'fs/promises';

Ùˆ Ø¨Ø¹Ø¯ Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¢Ù¾Ø¯ÛŒØª Ø´Ø¯ØŒ ÙØ§ÛŒÙ„ Ù‡Ù… Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ø¨Ø´Ù‡:

const oldMedia = await Media.findById(db, new ObjectId(id));
if (!oldMedia) {
  return NextResponse.json({ error: 'Old media not found' }, { status: 404 });
}

const oldPath = join(process.cwd(), 'public', oldMedia.path);
const newPath = join(process.cwd(), 'public', 'uploads', filename);

try {
  await rename(oldPath, newPath);
} catch (err) {
  console.error('Error renaming file on disk:', err);
  return NextResponse.json({ error: 'Failed to rename file on disk' }, { status: 500 });
}

// Ù‡Ù…Ú†Ù†ÛŒÙ† Ù…Ø³ÛŒØ± Ø¬Ø¯ÛŒØ¯ Ø±Ùˆ Ù‡Ù… ØªÙˆÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†:
await Media.update(db, new ObjectId(id), {
  filename,
  path: `/uploads/${filename}`
});

Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…:

    Ù…Ø·Ù…Ø¦Ù† Ø´Ùˆ filename Ú©Ù‡ Ú©Ø§Ø±Ø¨Ø± ÙˆØ§Ø±Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ù‡ Ù…Ø¹ØªØ¨Ø± Ø¨Ø§Ø´Ù‡ Ùˆ Ù¾Ø³ÙˆÙ†Ø¯ Ø±Ùˆ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù‡ (ÛŒØ§ Ø®ÙˆØ¯Ø´ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†).

    Ø­ÙˆØ§Ø³Øª Ø¨Ø§Ø´Ù‡ Ø§Ú¯Ø± ÙØ§ÛŒÙ„ Ø¨Ø§ Ù‡Ù…ÙˆÙ† Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ Ø§Ø² Ù‚Ø¨Ù„ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ù‡ØŒ Ø¨Ø§ÛŒØ¯ ÛŒÚ© Ù…Ú©Ø§Ù†ÛŒØ²Ù… Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ ÛŒØ§ ØªØºÛŒÛŒØ± Ù†Ø§Ù… (Ù…Ø«Ù„Ø§Ù‹ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡) Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ù†ÛŒ.

Ø§Ú¯Ù‡ Ø®ÙˆØ§Ø³ØªÛŒ Ø§ÙˆÙ† Ù‚Ø³Ù…Øª ØªØºÛŒÛŒØ± Ù†Ø§Ù… Ø§ØªÙˆÙ…Ø§ØªÛŒÚ© Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªÚ©Ø±Ø§Ø± Ø±Ùˆ Ù‡Ù… Ø¨Ø±Ø§Øª Ù…ÛŒâ€ŒÙ†ÙˆÛŒØ³Ù…. ğŸ‘Œ
You said:
Ø§ÛŒÙ†Ù… Ù‚Ø³Ù…Øª ØªØºÛŒÛŒØ± Ù†Ø§Ù… Ø§ØªÙˆÙ…Ø§ØªÛŒÚ© Ø¨Ù†ÙˆÛŒØ³ 
ChatGPT said:

Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ†Ú©Ù‡ ÙˆÙ‚ØªÛŒ Ù†Ø§Ù… ÙØ§ÛŒÙ„ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ù‡ØŒ ÙØ§ÛŒÙ„ Ø¯Ø§Ø®Ù„ Ù¾ÙˆØ´Ù‡ uploads Ù‡Ù… ØªØºÛŒÛŒØ± Ù†Ø§Ù… Ø¨Ø¯Ù‡ØŒ Ø¨Ø§ÛŒØ¯ Ø¯Ø± Ù…ØªØ¯ PUT Ú©Ù‡ Ù…Ø³Ø¦ÙˆÙ„ ÙˆÛŒØ±Ø§ÛŒØ´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø±Ø³Ø§Ù†Ù‡â€ŒÙ‡Ø§Ø³ØªØŒ Ù…Ø³ÛŒØ± ÙØ§ÛŒÙ„ Ù‚Ø¯ÛŒÙ…ÛŒ Ø±Ùˆ Ù¾ÛŒØ¯Ø§ Ú©Ù†ÛŒÙ… Ùˆ Ø§ÙˆÙ† Ø±Ùˆ Ø¨Ù‡ Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ ØªØºÛŒÛŒØ± Ø¨Ø¯ÛŒÙ…. Ø¯Ø± Ø§Ø¯Ø§Ù…Ù‡ Ù†Ø³Ø®Ù‡ Ø¨Ù‡â€ŒØ±ÙˆØ²â€ŒØ´Ø¯Ù‡â€ŒÛŒ ØªØ§Ø¨Ø¹ PUT Ø¯Ø± ÙØ§ÛŒÙ„ API /api/media Ø±Ùˆ Ù…ÛŒâ€ŒØ¨ÛŒÙ†ÛŒ:
ğŸ”§ ÙˆÛŒØ±Ø§ÛŒØ´ ØªØ§Ø¨Ø¹ PUT:

import { rename } from 'fs/promises';
import { join } from 'path';

export async function PUT(request) {
  try {
    const { id, filename } = await request.json();

    if (!id || !filename) {
      return NextResponse.json({ error: 'Missing required parameters' }, { status: 400 });
    }

    const client = await clientPromise;
    const db = client.db();

    // Ø§Ø¨ØªØ¯Ø§ ÙØ§ÛŒÙ„ Ù‚Ø¨Ù„ÛŒ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
    const mediaItem = await Media.findById(db, new ObjectId(id));
    if (!mediaItem) {
      return NextResponse.json({ error: 'Media not found' }, { status: 404 });
    }

    const oldFilename = mediaItem.filename;
    const extension = oldFilename.split('.').pop();
    const newFilename = `${filename}.${extension}`;

    const uploadDir = join(process.cwd(), 'public', 'uploads');
    const oldPath = join(uploadDir, oldFilename);
    const newPath = join(uploadDir, newFilename);

    // ØªØºÛŒÛŒØ± Ù†Ø§Ù… ÙØ§ÛŒÙ„ Ø¯Ø± ÙØ§ÛŒÙ„â€ŒØ³ÛŒØ³ØªÙ…
    await rename(oldPath, newPath);

    // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø³ÛŒØ± Ùˆ Ù†Ø§Ù… Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    await Media.update(db, new ObjectId(id), {
      filename: newFilename,
      path: `/uploads/${newFilename}`,
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error updating filename:', error);
    return NextResponse.json({ error: 'Failed to update filename' }, { status: 500 });
  }
}

âœ… Ù†Ú©Ø§Øª:

    Ø­ØªÙ…Ø§ Ù…Ø·Ù…Ø¦Ù† Ø´Ùˆ Ú©Ù‡ filename Ø¬Ø¯ÛŒØ¯ ÙÙ‚Ø· Ù†Ø§Ù… ÙØ§ÛŒÙ„ Ø¨Ø§Ø´Ù‡ØŒ Ø¨Ø¯ÙˆÙ† Ù¾Ø³ÙˆÙ†Ø¯ (Ù…Ø«Ù„ "new-name")ØŒ Ú†ÙˆÙ† Ù¾Ø³ÙˆÙ†Ø¯ Ø±Ùˆ Ø§Ø² Ù†Ø§Ù… Ø§ØµÙ„ÛŒ Ù‚Ø¨Ù„ÛŒ Ù…ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ… ØªØ§ ÙØ±Ù…Øª Ø­ÙØ¸ Ø¨Ø´Ù‡.

    Ø§Ú¯Ø± Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ù¾Ø³ÙˆÙ†Ø¯ Ù‡Ù… Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ± Ø¨Ø§Ø´Ù‡ØŒ Ø¨Ø§ÛŒØ¯ filename Ø±Ùˆ Ú©Ø§Ù…Ù„ (Ù…Ø«Ù„Ø§Ù‹ new-name.jpg) Ø¨ÙØ±Ø³ØªÛŒ Ùˆ Ø³Ù¾Ø³ Ø¨Ø§ path.extname Ùˆ path.basename Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù†ÛŒ.

Ø§Ú¯Ø± Ø®ÙˆØ§Ø³ØªÛŒ Ú©Ø§Ø±Ø¨Ø± Ù¾Ø³ÙˆÙ†Ø¯ Ø±Ùˆ Ù‡Ù… ØªØºÛŒÛŒØ± Ø¨Ø¯Ù‡ØŒ Ù…ÛŒâ€ŒØªÙˆÙ†Ù… Ø§ÙˆÙ† Ù†Ø³Ø®Ù‡ Ø±Ùˆ Ù‡Ù… Ø¨Ø±Ø§Øª Ø¨Ù†ÙˆÛŒØ³Ù….





@tiptap/react @tiptap/pm @tiptap/starter-kit @tiptap/extension-link @tiptap/extension-image





-----------------------------------------------------------------



'use client';

import { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Banner from './Banner';

export default function BannerSliderUltimate({ banners = [], className = '' }) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [direction, setDirection] = useState(0);
  const [isPaused, setIsPaused] = useState(false);

  // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú†Ø±Ø®Ø´ Ø®ÙˆØ¯Ú©Ø§Ø±
  const paginate = useCallback((newDirection) => {
    setDirection(newDirection);
    setCurrentIndex((prevIndex) => (prevIndex + newDirection + banners.length) % banners.length);
  }, [banners.length]);

  useEffect(() => {
    if (!isPaused) {
      const timer = setInterval(() => {
        paginate(1);
      }, 5000);

      return () => clearInterval(timer);
    }
  }, [isPaused, paginate]);

  // ...existing slideVariants code...

  const activeBanners = banners.filter(b => b.isActive);

  if (!activeBanners.length) return null;

  return (
    <div 
      className={`relative overflow-hidden w-full h-[200px] md:h-[300px] ${className}`}
      onMouseEnter={() => setIsPaused(true)}
      onMouseLeave={() => setIsPaused(false)}
    >
      <AnimatePresence initial={false} custom={direction}>
        <motion.div
          key={currentIndex}
          custom={direction}
          variants={slideVariants}
          initial="enter"
          animate="center"
          exit="exit"
          transition={{
            x: { type: "spring", stiffness: 300, damping: 30 },
            opacity: { duration: 0.2 }
          }}
          className="absolute w-full h-full"
          drag="x"
          dragConstraints={{ left: 0, right: 0 }}
          dragElastic={1}
          onDragEnd={(e, { offset, velocity }) => {
            const swipe = swipePower(offset.x, velocity.x);

            if (swipe < -swipeConfidenceThreshold) {
              paginate(1);
            } else if (swipe > swipeConfidenceThreshold) {
              paginate(-1);
            }
          }}
        >
          <Banner banner={activeBanners[currentIndex]} className="w-full h-full" />
        </motion.div>
      </AnimatePresence>

      {/* Dots indicator with improved styling */}
      <div className="absolute bottom-4 left-1/2 -translate-x-1/2 flex gap-3 z-10">
        {activeBanners.map((_, idx) => (
          <button
            key={idx}
            onClick={() => {
              setDirection(idx > currentIndex ? 1 : -1);
              setCurrentIndex(idx);
            }}
            className={`w-1.5 h-1.5 rounded-full transition-all duration-300 ${
              idx === currentIndex 
                ? 'bg-white w-4' 
                : 'bg-white/50 hover:bg-white/75'
            }`}
          />
        ))}
      </div>
    </div>
  );
}




// Ù…Ø«Ø§Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¨Ø§ Ù¾Ø±Ø§Ù¾Ø³â€ŒÙ‡Ø§ÛŒ Ø³ÙØ§Ø±Ø´ÛŒ
<BannerSliderUltimate 
  banners={banners} 
  className="rounded-lg shadow-lg"
  autoPlayInterval={5000} // Ø²Ù…Ø§Ù† Ú†Ø±Ø®Ø´ Ø¨Ù‡ Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡
  height={{ mobile: 200, desktop: 300 }} // Ø§Ø±ØªÙØ§Ø¹ Ø³ÙØ§Ø±Ø´ÛŒ
/>